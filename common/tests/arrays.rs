use ciborium::de::from_reader;
use ciborium::ser::into_writer;
use ciborium::value::Value;
use common::arrays::*;
use hex_literal::hex;

#[test]
fn hash_entry_cbor_test() {
    // The HashEntry struct is defined with the following seven procedural macros:
    // #[derive(Clone, Debug, PartialEq, Eq, StructToArray, Serialize, Deserialize)]
    //
    // cargo expand shows the following functions for HashEntry plus the additional HashEntryCbor
    // structure and its associated functions.
    // - HashEntry
    //  - Clone for HashEntry
    //  - Debug for HashEntry
    //  - PartialEq for HashEntry
    //  - Eq for HashEntry
    //  - Serialize for HashEntry
    //  - Deserialize<'de> for HashEntry
    //
    // Implementations generated by StructToArray
    // - HashEntryCbor
    //  - Clone for HashEntryCbor
    //  - Debug for HashEntryCbor
    //  - PartialEq for HashEntryCbor
    //  - TryFrom<HashEntryCbor> for HashEntry
    //  - TryFrom<HashEntry> for HashEntryCbor
    //  - TryFrom<&HashEntryCbor> for HashEntry
    //  - TryFrom<&HashEntry> for HashEntryCbor
    //  - TryFrom<Value> for HashEntryCbor
    //  - TryFrom<&Value> for HashEntryCbor
    //  - TryFrom<HashEntryCbor> for Vec<Value>
    //  - TryFrom<Vec<Value>> for HashEntryCbor
    //  - Serialize for HashEntryCbor
    //  - Deserialize for HashEntryCbor

    let some_bytes = hex!("a200c11a637cffdc01c11a637d0decffa200c11a637cffdc01c11a637d0decff");
    let scratch = HashEntryCbor {
        hash_alg_id: 1,
        hash_value: some_bytes.to_vec(),
    };
    //  - Clone for HashEntryCbor
    let scratch_clone = scratch.clone();

    //  - Debug for HashEntryCbor
    let _s = format!("{scratch:?}");

    //  - PartialEq for HashEntryCbor
    assert_eq!(scratch_clone, scratch);
    assert!(scratch_clone == scratch);
    assert!(!(scratch_clone != scratch));

    //  - Serialize for HashEntryCbor
    let mut encoded_cbor = vec![];
    let _ = into_writer(&scratch, &mut encoded_cbor);

    //  - Deserialize for HashEntryCbor
    let value: Value = from_reader(encoded_cbor.clone().as_slice()).unwrap();
    let cbor_from_value: HashEntryCbor = HashEntryCbor::try_from(&value).unwrap();
    assert!(scratch == cbor_from_value);

    let mut busted = encoded_cbor.clone();
    busted[0] = 0xA2;
    let value: Result<HashEntryCbor, _> = from_reader(busted.clone().as_slice());
    assert!(value.is_err());

    let decoded: HashEntryCbor = from_reader(encoded_cbor.clone().as_slice()).unwrap();
    let mut encoded_token_roundtrip = vec![];
    let _ = into_writer(&decoded, &mut encoded_token_roundtrip);
    assert_eq!(encoded_cbor, encoded_token_roundtrip);
    assert_eq!(scratch, decoded);
    assert_eq!(decoded.hash_value, some_bytes);
    assert_eq!(decoded.hash_alg_id, 1);
    assert!(scratch == decoded);

    let mut decoded2: HashEntryCbor = decoded.clone();
    decoded2.hash_alg_id = 2;
    assert_ne!(scratch, decoded2);

    {
        let value: Value = from_reader(encoded_cbor.clone().as_slice()).unwrap();
        //  - TryFrom<&Value> for HashEntryCbor
        let cbor_from_value: HashEntryCbor = HashEntryCbor::try_from(&value).unwrap();
        //  - TryFrom<Value> for HashEntryCbor
        let cbor_from_value2: HashEntryCbor = HashEntryCbor::try_from(value).unwrap();
        assert!(scratch == cbor_from_value);
        assert!(scratch == cbor_from_value2);
    }

    let value: Value = from_reader(encoded_cbor.clone().as_slice()).unwrap();
    let value2 = &value.clone();
    //  - TryFrom<Value> for HashEntryCbor
    let cbor_from_value2: HashEntryCbor = value.try_into().unwrap();
    //  - TryFrom<&Value> for HashEntryCbor
    let cbor_from_value: HashEntryCbor = value2.try_into().unwrap();
    assert!(scratch == cbor_from_value);
    assert!(scratch == cbor_from_value2);

    {
        let tt = &cbor_from_value2;
        //  - TryFrom<&HashEntryCbor> for Vec<Value>
        let vec_value: Vec<Value> = tt.try_into().unwrap();

        //  - TryFrom<Vec<Value>> for HashEntryCbor
        let tt2: HashEntryCbor = vec_value.try_into().unwrap();
        assert_eq!(tt, &tt2);
    }
    {
        pub type TempType = Vec<Value>;
        //  - TryFrom<&HashEntryCbor> for Vec<Value>
        let vec_value = TempType::try_from(&cbor_from_value2).unwrap();

        //  - TryFrom<Vec<Value>> for HashEntryCbor
        let tt2: HashEntryCbor = HashEntryCbor::try_from(vec_value).unwrap();
        assert_eq!(&cbor_from_value2, &tt2);
    }

    //  - TryFrom<&HashEntryCbor> for HashEntry
    let json_from_cbor3: HashEntry = HashEntry::try_from(&decoded).unwrap();
    let tmp_cbor = &decoded.clone();
    //  - TryFrom<HashEntryCbor> for HashEntry
    let json_from_cbor2: HashEntry = HashEntry::try_from(tmp_cbor).unwrap();

    let json_from_cbor: HashEntry = decoded.try_into().unwrap();
    assert_eq!(json_from_cbor, json_from_cbor2);
    assert_eq!(json_from_cbor, json_from_cbor3);
    let json_from_cbor_clone = json_from_cbor.clone();
    assert_eq!(json_from_cbor_clone, json_from_cbor);
    assert!(json_from_cbor_clone == json_from_cbor);
    assert_eq!(json_from_cbor.hash_value, some_bytes);
    assert_eq!(json_from_cbor.hash_alg_id, 1);
    let _s = format!("{json_from_cbor:?}");

    // - Serialize for HashEntry
    let encoded_json = serde_json::to_string(&json_from_cbor).unwrap();
    // - Deserialize<'de> for HashEntry
    let decoded_json: HashEntry = serde_json::from_str(encoded_json.as_str()).unwrap();
    assert_eq!(decoded_json, json_from_cbor);

    //  - TryFrom<HashEntry> for HashEntryCbor
    let cbor_from_json: HashEntryCbor = json_from_cbor.try_into().unwrap();
    // - Clone for HashEntry
    let tmp_json = decoded_json.clone();
    //  - Debug for HashEntryCbor
    let _s = format!("{tmp_json:?}");

    // - PartialEq for HashEntryCbor
    // - Eq for HashEntry
    assert_eq!(tmp_json, decoded_json);
    assert!(tmp_json == decoded_json);
    assert!(!(tmp_json != decoded_json));

    //  - TryFrom<&HashEntry> for HashEntryCbor
    let cbor_from_json2: HashEntryCbor = HashEntryCbor::try_from(&tmp_json).unwrap();
    assert_eq!(cbor_from_json2, cbor_from_json);

    let cbor_clone = cbor_from_json.clone();
    assert_eq!(cbor_clone, cbor_from_json);
    assert!(cbor_clone == cbor_from_json);

    let mut encoded_cbor_from_json = vec![];
    let _ = into_writer(&cbor_from_json, &mut encoded_cbor_from_json);
    assert_eq!(encoded_cbor, encoded_cbor_from_json);
}

#[test]
fn hash_entry_json_test() {
    let some_bytes = hex!("a200c11a637cffdc01c11a637d0decffa200c11a637cffdc01c11a637d0decff");
    let scratch = HashEntry {
        hash_alg_id: 1,
        hash_value: some_bytes.to_vec(),
    };
    let scratch_clone = scratch.clone();
    assert_eq!(scratch_clone, scratch);

    let json_encoded = serde_json::to_string(&scratch).unwrap();
    let decoded: HashEntry = serde_json::from_str(json_encoded.as_str()).unwrap();
    let decoded2: HashEntry = decoded.clone();
    let json_encoded_roundtrip = serde_json::to_string(&decoded).unwrap();
    assert_eq!(json_encoded, json_encoded_roundtrip);
    assert_eq!(scratch, decoded);
    assert_eq!(scratch, decoded2);
    assert_eq!(decoded.hash_value, some_bytes);
    assert_eq!(decoded.hash_alg_id, 1);
    assert!(scratch == decoded);
    let _s = format!("{scratch:?}");

    let cbor_from_json: HashEntryCbor = decoded.try_into().unwrap();
    let cbor_from_json_clone = cbor_from_json.clone();
    assert_eq!(cbor_from_json_clone, cbor_from_json);
    assert!(cbor_from_json_clone == cbor_from_json);
    let _s = format!("{cbor_from_json:?}");

    let mut encoded_cbor = vec![];
    let _ = into_writer(&cbor_from_json, &mut encoded_cbor);
    let decoded_cbor: HashEntryCbor = from_reader(encoded_cbor.clone().as_slice()).unwrap();
    let json_from_cbor: HashEntry = decoded_cbor.try_into().unwrap();
    let json_from_cbor_clone = json_from_cbor.clone();
    assert_eq!(json_from_cbor_clone, json_from_cbor);
    assert!(json_from_cbor_clone == json_from_cbor);
}

#[test]
fn hash_entry_default_cbor_test() {
    let mut encoded_cbor = vec![];
    let some_bytes = hex!("a200c11a637cffdc01c11a637d0decffa200c11a637cffdc01c11a637d0decff");
    let scratch = HashEntry {
        hash_alg_id: 1,
        hash_value: some_bytes.to_vec(),
    };

    let _ = into_writer(&scratch, &mut encoded_cbor);
    let decoded: HashEntry = from_reader(encoded_cbor.clone().as_slice()).unwrap();
    let decoded2: HashEntry = decoded.clone();
    let mut encoded_token_roundtrip = vec![];
    let _ = into_writer(&decoded, &mut encoded_token_roundtrip);
    assert_eq!(encoded_cbor, encoded_token_roundtrip);
    assert_eq!(scratch, decoded);
    assert_eq!(scratch, decoded2);
    assert_eq!(decoded.hash_value, some_bytes);
    assert_eq!(decoded.hash_alg_id, 1);
    assert!(scratch == decoded);
    let _s = format!("{scratch:?}");
}
